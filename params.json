{"name":"Marsdb","tagline":"MarsDB is a Promise based lightweight database with MongoDB query syntax, written on ES6","body":"<div style=\"text-align:center\"><img src=\"https://static.studytime.me/marsdb.png\" /></div>\r\n\r\nMarsDB\r\n=========\r\n\r\n[![Build Status](https://travis-ci.org/c58/marsdb.svg?branch=master)](https://travis-ci.org/c58/marsdb)\r\n[![npm version](https://badge.fury.io/js/marsdb.svg)](https://www.npmjs.com/package/marsdb)\r\n[![Coverage Status](https://coveralls.io/repos/c58/marsdb/badge.svg?branch=master&service=github)](https://coveralls.io/github/c58/marsdb?branch=master)\r\n[![Dependency Status](https://david-dm.org/c58/marsdb.svg)](https://david-dm.org/c58/marsdb)\r\n\r\nMarsDB is a lightweight client-side database.\r\nIt's based on a Meteor’s `minimongo` matching/modifying implementation. It's carefully written on `ES6`, usess `modular lodash`, have a `Promise` based interface and may be backed with any storage implementation (LevelUP, LocalStorage, IndexedDB, etc). For now implemented only LocalStorage and [LocalForage](https://github.com/mozilla/localForage) storage managers. It's also supports `observable` cursors.\r\n\r\nMarsDB supports any kind of find/update/remove operations that Meteor’s minimongo does. So, go to the Meteor docs for supported query/modifier operations.\r\n\r\nYou can use it in any JS environment (Browser, Electron, NW.js, Node.js).\r\n\r\n## Features\r\n\r\n* **Promise based API**\r\n* **Carefully written on ES6**\r\n* **Supports many of MongoDB query/modify operations** – thanks to a Meteor’s minimongo\r\n* **Flexible pipeline** – map, reduce, custom sorting function, filtering. All with a sexy JS interface (no ugly mongo’s aggregation language)\r\n* **Persistence API** – all collections can be stored (and restored) with any kind of storage (in-memory, LocalStorage, LevelUP, etc)\r\n* **Observable queries** - live queries just like in Meteor, but with simplier interface\r\n* **Reactive joins** – out of the box\r\n\r\n## Examples\r\n### Using with Angular 1.x\r\nInclude `marsdb.angular.js` after `marsdb.min.js` and `angular.js` in your `<head>`. Then add a `MarsDB` dependency in your module. That's it. Now you can use `$collection` factory. For example:\r\n```javascript\r\nangular.module(‘app’, [‘MarsDB’])\r\n\t.controller(function($scope, $collection) {\r\n\t\tconst posts = $collection(‘posts’);\r\n\r\n\t\t// All methods in $collection returns a $q promise\r\n\t\t// So you don’t need to manually call $digest\r\n\t\tposts.find({authorId: 123}).observe((docs) => {\r\n\t\t\t$scope.posts = docs;\r\n\t\t}, $scope).then(() => {\r\n\t\t\t$scope.loaded = true;\r\n\t\t});\r\n\r\n\t\t// $scope at last argument needed for auto-binding\r\n\t\t// to a “$destroy” event of the scope for stop\r\n\t\t// observing changes. You can call it manually and\r\n\t\t// don’t pass last argument.\r\n\t});\r\n```\r\n\r\nYou also can use MarsDB within browserify environment. Just `require(‘marsdb/dist/angular’)` and MarsDB module will be added to the angular. Angular must be defined in a `window` or must be available as a module `require(‘angular’)`.\r\n\r\n### Using within non-ES6 environment\r\nThe `./dist` folder contains already compiled to a ES5 code, but some polyfills needed. For using in a browser you must to include `marsdb.polyfills.js` before `marsdb.min.js`. In node.js you need to `require(‘marsdb/polyfills’)`.\r\nIt sets in a window/global: Promise, Set and Symbol.\r\n\r\n### Create a collection\r\n```javascript\r\nimport Collection from ‘marsdb’;\r\nimport LocalStorageManager from 'marsdb/lib/LocalStorageManager';\r\n\r\n// Setup different id generator and storage managers\r\n// Default storage is in-memory\r\nCollection.defaultStorageManager(LocalStorageManager);\r\nCollection.defaultIdGenerator(() => {\r\n  return {\r\n    value: Math.random(),\r\n    seed: 0,\r\n  };\r\n});\r\n\r\nconst users = new Collection(‘users’);\r\n```\r\n### Find a documents\r\n```javascript\r\nconst posts = new Collection(‘posts’);\r\nposts.find({author: ‘Bob’})\r\n  .sort([‘createdAt’])\r\n  .then(docs => {\r\n    // do something with docs\r\n  });\r\n```\r\n### Find with pipeline (map, reduce, filter)\r\nAn order of pipeline methods invokation is important. Next pipeline operation gives as argument a result of a previous operation.\r\n```javascript\r\nconst posts = new Collection(‘posts’);\r\nposts.find()\r\n  .limit(10)\r\n  .sortFunc((a, b) => a - b + 10)\r\n  .filter(doc => Matsh.sqrt(doc.comment.length) > 1.5)\r\n  .map(doc => doc.comments.length)\r\n  .reduce((acum, val) => acum + val)\r\n  .then(result => {\r\n    // result is a sum of coutn of comments\r\n    // in all found posts\r\n  });\r\n```\r\n### Find with observing changes\r\nObservable cursor returned only by a `find` method of a collection. Updates of the cursor is batched and debounced (default batch size is `20` and debounce time is `1000 / 15` ms). You can change the paramters by `batchSize` and `debounce` methods of an observable cursor (methods is chained).\r\n\r\n```javascript\r\nconst posts = new Collection(‘posts’);\r\nconst stopper = posts.find({tags: {$in: [‘marsdb’, ‘is’, ‘awesome’]}})\r\n  .observe(docs => {\r\n    // invoked on every result change\r\n    // (on initial result too)\r\n    stopper.stop(); // stops observing\r\n  }).then(docs => {\r\n    // invoked once on initial result\r\n    // (after `observer` callback)\r\n  });\r\n```\r\n\r\n### Find with joins\r\n```javascript\r\nconst users = new Collection(‘users’);\r\nconst posts = new Collection(‘posts’);\r\nposts.find()\r\n  .join(doc => {\r\n    // Return a Promise for waiting of the result.\r\n    return users.findOne(doc.authorId).then(user => {\r\n      doc.authorObj = user;\r\n      // any return is ignored\r\n    });\r\n  })\r\n  .join(doc => {\r\n    // For reactive join you must invoke `observe` instead `then`\r\n    // That's it!\r\n    return users.findOne(doc.authorId).observe(user => {\r\n      doc.authorObj = user;\r\n    });\r\n  })\r\n  .join(doc => {\r\n    // Also any other “join” mutations supported\r\n    doc.another = _cached_data_by_post[doc._id];\r\n  })\r\n  .observe((posts) => {\r\n    // do something with posts with authors\r\n    // invoked any time when posts changed\r\n    // (and when observed joins changed too)\r\n  })\r\n```\r\n### Inserting\r\n```javascript\r\nconst posts = new Collection(‘posts’);\r\nposts.insert({text: ‘MarsDB is awesome’}).then(docId => {\r\n  // Invoked after persisting document\r\n})\r\nposts.insertAll(\r\n  {text: ‘MarsDB’},\r\n  {text: ‘is’},\r\n  {text: ‘awesome’}\r\n).then(docsIds => {\r\n  // invoked when all documents inserted\r\n});\r\n```\r\n### Updating\r\n```javascript\r\nconst posts = new Collection(‘posts’);\r\nposts.update(\r\n  {authorId: {$in: [1, 2, 3]}},\r\n  {$set: {text: ‘noop’}}\r\n).then(result => {\r\n  console.log(result.modified) // count of modified docs\r\n  console.log(result.updated) // array of updated docs\r\n  console.log(result.original) // array of original docs\r\n});\r\n```\r\n### Removing\r\n```javascript\r\nconst posts = new Collection(‘posts’);\r\nposts.remove({authorId: {$in: [1,2,3]}})\r\n  .then(removedDocs => {\r\n    // do something with removed documents array\r\n  });\r\n```\r\n\r\n## Roadmap\r\n* Keep track of multiple remove/update documents in selector (allow only if opations.multi passed)\r\n* Upsert updating\r\n* Indexes support for some kind of simple requests {a: '^b'}, {a: {$lt: 9}}\r\n* Some set of backends\r\n* Documentation\r\n\r\n## Contributing\r\nI’m waiting for your pull requests and issues.\r\nDon’t forget to execute `gulp lint` before requesting. Accepted only requests without errors.\r\n\r\n## License\r\nSee [License](LICENSE)","google":"UA-69146623-1","note":"Don't delete this file! It's used internally to help with page regeneration."}